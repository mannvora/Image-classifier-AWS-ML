export interface AcceleratorCount {
  Min?: number;
  Max?: number;
}
export interface AcceleratorCountRequest {
  Min?: number;
  Max?: number;
}
export declare const AcceleratorManufacturer: {
  readonly AMAZON_WEB_SERVICES: "amazon-web-services";
  readonly AMD: "amd";
  readonly HABANA: "habana";
  readonly NVIDIA: "nvidia";
  readonly XILINX: "xilinx";
};
export type AcceleratorManufacturer =
  (typeof AcceleratorManufacturer)[keyof typeof AcceleratorManufacturer];
export declare const AcceleratorName: {
  readonly A100: "a100";
  readonly A10G: "a10g";
  readonly H100: "h100";
  readonly INFERENTIA: "inferentia";
  readonly K520: "k520";
  readonly K80: "k80";
  readonly M60: "m60";
  readonly RADEON_PRO_V520: "radeon-pro-v520";
  readonly T4: "t4";
  readonly T4G: "t4g";
  readonly V100: "v100";
  readonly VU9P: "vu9p";
};
export type AcceleratorName =
  (typeof AcceleratorName)[keyof typeof AcceleratorName];
export interface AcceleratorTotalMemoryMiB {
  Min?: number;
  Max?: number;
}
export interface AcceleratorTotalMemoryMiBRequest {
  Min?: number;
  Max?: number;
}
export declare const AcceleratorType: {
  readonly FPGA: "fpga";
  readonly GPU: "gpu";
  readonly INFERENCE: "inference";
};
export type AcceleratorType =
  (typeof AcceleratorType)[keyof typeof AcceleratorType];
export declare const ResourceType: {
  readonly capacity_reservation: "capacity-reservation";
  readonly capacity_reservation_fleet: "capacity-reservation-fleet";
  readonly carrier_gateway: "carrier-gateway";
  readonly client_vpn_endpoint: "client-vpn-endpoint";
  readonly coip_pool: "coip-pool";
  readonly customer_gateway: "customer-gateway";
  readonly dedicated_host: "dedicated-host";
  readonly dhcp_options: "dhcp-options";
  readonly egress_only_internet_gateway: "egress-only-internet-gateway";
  readonly elastic_gpu: "elastic-gpu";
  readonly elastic_ip: "elastic-ip";
  readonly export_image_task: "export-image-task";
  readonly export_instance_task: "export-instance-task";
  readonly fleet: "fleet";
  readonly fpga_image: "fpga-image";
  readonly host_reservation: "host-reservation";
  readonly image: "image";
  readonly import_image_task: "import-image-task";
  readonly import_snapshot_task: "import-snapshot-task";
  readonly instance: "instance";
  readonly instance_connect_endpoint: "instance-connect-endpoint";
  readonly instance_event_window: "instance-event-window";
  readonly internet_gateway: "internet-gateway";
  readonly ipam: "ipam";
  readonly ipam_external_resource_verification_token: "ipam-external-resource-verification-token";
  readonly ipam_pool: "ipam-pool";
  readonly ipam_resource_discovery: "ipam-resource-discovery";
  readonly ipam_resource_discovery_association: "ipam-resource-discovery-association";
  readonly ipam_scope: "ipam-scope";
  readonly ipv4pool_ec2: "ipv4pool-ec2";
  readonly ipv6pool_ec2: "ipv6pool-ec2";
  readonly key_pair: "key-pair";
  readonly launch_template: "launch-template";
  readonly local_gateway: "local-gateway";
  readonly local_gateway_route_table: "local-gateway-route-table";
  readonly local_gateway_route_table_virtual_interface_group_association: "local-gateway-route-table-virtual-interface-group-association";
  readonly local_gateway_route_table_vpc_association: "local-gateway-route-table-vpc-association";
  readonly local_gateway_virtual_interface: "local-gateway-virtual-interface";
  readonly local_gateway_virtual_interface_group: "local-gateway-virtual-interface-group";
  readonly natgateway: "natgateway";
  readonly network_acl: "network-acl";
  readonly network_insights_access_scope: "network-insights-access-scope";
  readonly network_insights_access_scope_analysis: "network-insights-access-scope-analysis";
  readonly network_insights_analysis: "network-insights-analysis";
  readonly network_insights_path: "network-insights-path";
  readonly network_interface: "network-interface";
  readonly placement_group: "placement-group";
  readonly prefix_list: "prefix-list";
  readonly replace_root_volume_task: "replace-root-volume-task";
  readonly reserved_instances: "reserved-instances";
  readonly route_table: "route-table";
  readonly security_group: "security-group";
  readonly security_group_rule: "security-group-rule";
  readonly snapshot: "snapshot";
  readonly spot_fleet_request: "spot-fleet-request";
  readonly spot_instances_request: "spot-instances-request";
  readonly subnet: "subnet";
  readonly subnet_cidr_reservation: "subnet-cidr-reservation";
  readonly traffic_mirror_filter: "traffic-mirror-filter";
  readonly traffic_mirror_filter_rule: "traffic-mirror-filter-rule";
  readonly traffic_mirror_session: "traffic-mirror-session";
  readonly traffic_mirror_target: "traffic-mirror-target";
  readonly transit_gateway: "transit-gateway";
  readonly transit_gateway_attachment: "transit-gateway-attachment";
  readonly transit_gateway_connect_peer: "transit-gateway-connect-peer";
  readonly transit_gateway_multicast_domain: "transit-gateway-multicast-domain";
  readonly transit_gateway_policy_table: "transit-gateway-policy-table";
  readonly transit_gateway_route_table: "transit-gateway-route-table";
  readonly transit_gateway_route_table_announcement: "transit-gateway-route-table-announcement";
  readonly verified_access_endpoint: "verified-access-endpoint";
  readonly verified_access_group: "verified-access-group";
  readonly verified_access_instance: "verified-access-instance";
  readonly verified_access_policy: "verified-access-policy";
  readonly verified_access_trust_provider: "verified-access-trust-provider";
  readonly volume: "volume";
  readonly vpc: "vpc";
  readonly vpc_block_public_access_exclusion: "vpc-block-public-access-exclusion";
  readonly vpc_endpoint: "vpc-endpoint";
  readonly vpc_endpoint_connection: "vpc-endpoint-connection";
  readonly vpc_endpoint_connection_device_type: "vpc-endpoint-connection-device-type";
  readonly vpc_endpoint_service: "vpc-endpoint-service";
  readonly vpc_endpoint_service_permission: "vpc-endpoint-service-permission";
  readonly vpc_flow_log: "vpc-flow-log";
  readonly vpc_peering_connection: "vpc-peering-connection";
  readonly vpn_connection: "vpn-connection";
  readonly vpn_connection_device_type: "vpn-connection-device-type";
  readonly vpn_gateway: "vpn-gateway";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface TagSpecification {
  ResourceType?: ResourceType;
  Tags?: Tag[];
}
export interface AcceptAddressTransferRequest {
  Address: string | undefined;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export declare const AddressTransferStatus: {
  readonly accepted: "accepted";
  readonly disabled: "disabled";
  readonly pending: "pending";
};
export type AddressTransferStatus =
  (typeof AddressTransferStatus)[keyof typeof AddressTransferStatus];
export interface AddressTransfer {
  PublicIp?: string;
  AllocationId?: string;
  TransferAccountId?: string;
  TransferOfferExpirationTimestamp?: Date;
  TransferOfferAcceptedTimestamp?: Date;
  AddressTransferStatus?: AddressTransferStatus;
}
export interface AcceptAddressTransferResult {
  AddressTransfer?: AddressTransfer;
}
export interface AcceptCapacityReservationBillingOwnershipRequest {
  DryRun?: boolean;
  CapacityReservationId: string | undefined;
}
export interface AcceptCapacityReservationBillingOwnershipResult {
  Return?: boolean;
}
export interface TargetConfigurationRequest {
  InstanceCount?: number;
  OfferingId: string | undefined;
}
export interface AcceptReservedInstancesExchangeQuoteRequest {
  DryRun?: boolean;
  ReservedInstanceIds: string[] | undefined;
  TargetConfigurations?: TargetConfigurationRequest[];
}
export interface AcceptReservedInstancesExchangeQuoteResult {
  ExchangeId?: string;
}
export interface AcceptTransitGatewayMulticastDomainAssociationsRequest {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  SubnetIds?: string[];
  DryRun?: boolean;
}
export declare const TransitGatewayAttachmentResourceType: {
  readonly connect: "connect";
  readonly direct_connect_gateway: "direct-connect-gateway";
  readonly peering: "peering";
  readonly tgw_peering: "tgw-peering";
  readonly vpc: "vpc";
  readonly vpn: "vpn";
};
export type TransitGatewayAttachmentResourceType =
  (typeof TransitGatewayAttachmentResourceType)[keyof typeof TransitGatewayAttachmentResourceType];
export declare const TransitGatewayMulitcastDomainAssociationState: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
  readonly failed: "failed";
  readonly pendingAcceptance: "pendingAcceptance";
  readonly rejected: "rejected";
};
export type TransitGatewayMulitcastDomainAssociationState =
  (typeof TransitGatewayMulitcastDomainAssociationState)[keyof typeof TransitGatewayMulitcastDomainAssociationState];
export interface SubnetAssociation {
  SubnetId?: string;
  State?: TransitGatewayMulitcastDomainAssociationState;
}
export interface TransitGatewayMulticastDomainAssociations {
  TransitGatewayMulticastDomainId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  ResourceOwnerId?: string;
  Subnets?: SubnetAssociation[];
}
export interface AcceptTransitGatewayMulticastDomainAssociationsResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export interface AcceptTransitGatewayPeeringAttachmentRequest {
  TransitGatewayAttachmentId: string | undefined;
  DryRun?: boolean;
}
export interface PeeringTgwInfo {
  TransitGatewayId?: string;
  CoreNetworkId?: string;
  OwnerId?: string;
  Region?: string;
}
export declare const DynamicRoutingValue: {
  readonly disable: "disable";
  readonly enable: "enable";
};
export type DynamicRoutingValue =
  (typeof DynamicRoutingValue)[keyof typeof DynamicRoutingValue];
export interface TransitGatewayPeeringAttachmentOptions {
  DynamicRouting?: DynamicRoutingValue;
}
export declare const TransitGatewayAttachmentState: {
  readonly available: "available";
  readonly deleted: "deleted";
  readonly deleting: "deleting";
  readonly failed: "failed";
  readonly failing: "failing";
  readonly initiating: "initiating";
  readonly initiatingRequest: "initiatingRequest";
  readonly modifying: "modifying";
  readonly pending: "pending";
  readonly pendingAcceptance: "pendingAcceptance";
  readonly rejected: "rejected";
  readonly rejecting: "rejecting";
  readonly rollingBack: "rollingBack";
};
export type TransitGatewayAttachmentState =
  (typeof TransitGatewayAttachmentState)[keyof typeof TransitGatewayAttachmentState];
export interface PeeringAttachmentStatus {
  Code?: string;
  Message?: string;
}
export interface TransitGatewayPeeringAttachment {
  TransitGatewayAttachmentId?: string;
  AccepterTransitGatewayAttachmentId?: string;
  RequesterTgwInfo?: PeeringTgwInfo;
  AccepterTgwInfo?: PeeringTgwInfo;
  Options?: TransitGatewayPeeringAttachmentOptions;
  Status?: PeeringAttachmentStatus;
  State?: TransitGatewayAttachmentState;
  CreationTime?: Date;
  Tags?: Tag[];
}
export interface AcceptTransitGatewayPeeringAttachmentResult {
  TransitGatewayPeeringAttachment?: TransitGatewayPeeringAttachment;
}
export interface AcceptTransitGatewayVpcAttachmentRequest {
  TransitGatewayAttachmentId: string | undefined;
  DryRun?: boolean;
}
export declare const ApplianceModeSupportValue: {
  readonly disable: "disable";
  readonly enable: "enable";
};
export type ApplianceModeSupportValue =
  (typeof ApplianceModeSupportValue)[keyof typeof ApplianceModeSupportValue];
export declare const DnsSupportValue: {
  readonly disable: "disable";
  readonly enable: "enable";
};
export type DnsSupportValue =
  (typeof DnsSupportValue)[keyof typeof DnsSupportValue];
export declare const Ipv6SupportValue: {
  readonly disable: "disable";
  readonly enable: "enable";
};
export type Ipv6SupportValue =
  (typeof Ipv6SupportValue)[keyof typeof Ipv6SupportValue];
export declare const SecurityGroupReferencingSupportValue: {
  readonly disable: "disable";
  readonly enable: "enable";
};
export type SecurityGroupReferencingSupportValue =
  (typeof SecurityGroupReferencingSupportValue)[keyof typeof SecurityGroupReferencingSupportValue];
export interface TransitGatewayVpcAttachmentOptions {
  DnsSupport?: DnsSupportValue;
  SecurityGroupReferencingSupport?: SecurityGroupReferencingSupportValue;
  Ipv6Support?: Ipv6SupportValue;
  ApplianceModeSupport?: ApplianceModeSupportValue;
}
export interface TransitGatewayVpcAttachment {
  TransitGatewayAttachmentId?: string;
  TransitGatewayId?: string;
  VpcId?: string;
  VpcOwnerId?: string;
  State?: TransitGatewayAttachmentState;
  SubnetIds?: string[];
  CreationTime?: Date;
  Options?: TransitGatewayVpcAttachmentOptions;
  Tags?: Tag[];
}
export interface AcceptTransitGatewayVpcAttachmentResult {
  TransitGatewayVpcAttachment?: TransitGatewayVpcAttachment;
}
export interface AcceptVpcEndpointConnectionsRequest {
  DryRun?: boolean;
  ServiceId: string | undefined;
  VpcEndpointIds: string[] | undefined;
}
export interface UnsuccessfulItemError {
  Code?: string;
  Message?: string;
}
export interface UnsuccessfulItem {
  Error?: UnsuccessfulItemError;
  ResourceId?: string;
}
export interface AcceptVpcEndpointConnectionsResult {
  Unsuccessful?: UnsuccessfulItem[];
}
export interface AcceptVpcPeeringConnectionRequest {
  DryRun?: boolean;
  VpcPeeringConnectionId: string | undefined;
}
export interface CidrBlock {
  CidrBlock?: string;
}
export interface Ipv6CidrBlock {
  Ipv6CidrBlock?: string;
}
export interface VpcPeeringConnectionOptionsDescription {
  AllowDnsResolutionFromRemoteVpc?: boolean;
  AllowEgressFromLocalClassicLinkToRemoteVpc?: boolean;
  AllowEgressFromLocalVpcToRemoteClassicLink?: boolean;
}
export interface VpcPeeringConnectionVpcInfo {
  CidrBlock?: string;
  Ipv6CidrBlockSet?: Ipv6CidrBlock[];
  CidrBlockSet?: CidrBlock[];
  OwnerId?: string;
  PeeringOptions?: VpcPeeringConnectionOptionsDescription;
  VpcId?: string;
  Region?: string;
}
export declare const VpcPeeringConnectionStateReasonCode: {
  readonly active: "active";
  readonly deleted: "deleted";
  readonly deleting: "deleting";
  readonly expired: "expired";
  readonly failed: "failed";
  readonly initiating_request: "initiating-request";
  readonly pending_acceptance: "pending-acceptance";
  readonly provisioning: "provisioning";
  readonly rejected: "rejected";
};
export type VpcPeeringConnectionStateReasonCode =
  (typeof VpcPeeringConnectionStateReasonCode)[keyof typeof VpcPeeringConnectionStateReasonCode];
export interface VpcPeeringConnectionStateReason {
  Code?: VpcPeeringConnectionStateReasonCode;
  Message?: string;
}
export interface VpcPeeringConnection {
  AccepterVpcInfo?: VpcPeeringConnectionVpcInfo;
  ExpirationTime?: Date;
  RequesterVpcInfo?: VpcPeeringConnectionVpcInfo;
  Status?: VpcPeeringConnectionStateReason;
  Tags?: Tag[];
  VpcPeeringConnectionId?: string;
}
export interface AcceptVpcPeeringConnectionResult {
  VpcPeeringConnection?: VpcPeeringConnection;
}
export interface PortRange {
  From?: number;
  To?: number;
}
export interface AnalysisAclRule {
  Cidr?: string;
  Egress?: boolean;
  PortRange?: PortRange;
  Protocol?: string;
  RuleAction?: string;
  RuleNumber?: number;
}
export interface AnalysisComponent {
  Id?: string;
  Arn?: string;
  Name?: string;
}
export interface RuleOption {
  Keyword?: string;
  Settings?: string[];
}
export interface RuleGroupRuleOptionsPair {
  RuleGroupArn?: string;
  RuleOptions?: RuleOption[];
}
export interface RuleGroupTypePair {
  RuleGroupArn?: string;
  RuleGroupType?: string;
}
export interface AdditionalDetail {
  AdditionalDetailType?: string;
  Component?: AnalysisComponent;
  VpcEndpointService?: AnalysisComponent;
  RuleOptions?: RuleOption[];
  RuleGroupTypePairs?: RuleGroupTypePair[];
  RuleGroupRuleOptionsPairs?: RuleGroupRuleOptionsPair[];
  ServiceName?: string;
  LoadBalancers?: AnalysisComponent[];
}
export interface AnalysisLoadBalancerListener {
  LoadBalancerPort?: number;
  InstancePort?: number;
}
export interface FirewallStatefulRule {
  RuleGroupArn?: string;
  Sources?: string[];
  Destinations?: string[];
  SourcePorts?: PortRange[];
  DestinationPorts?: PortRange[];
  Protocol?: string;
  RuleAction?: string;
  Direction?: string;
}
export interface FirewallStatelessRule {
  RuleGroupArn?: string;
  Sources?: string[];
  Destinations?: string[];
  SourcePorts?: PortRange[];
  DestinationPorts?: PortRange[];
  Protocols?: number[];
  RuleAction?: string;
  Priority?: number;
}
export interface AnalysisLoadBalancerTarget {
  Address?: string;
  AvailabilityZone?: string;
  Instance?: AnalysisComponent;
  Port?: number;
}
export interface AnalysisRouteTableRoute {
  DestinationCidr?: string;
  DestinationPrefixListId?: string;
  EgressOnlyInternetGatewayId?: string;
  GatewayId?: string;
  InstanceId?: string;
  NatGatewayId?: string;
  NetworkInterfaceId?: string;
  Origin?: string;
  TransitGatewayId?: string;
  VpcPeeringConnectionId?: string;
  State?: string;
  CarrierGatewayId?: string;
  CoreNetworkArn?: string;
  LocalGatewayId?: string;
}
export interface AnalysisSecurityGroupRule {
  Cidr?: string;
  Direction?: string;
  SecurityGroupId?: string;
  PortRange?: PortRange;
  PrefixListId?: string;
  Protocol?: string;
}
export interface TransitGatewayRouteTableRoute {
  DestinationCidr?: string;
  State?: string;
  RouteOrigin?: string;
  PrefixListId?: string;
  AttachmentId?: string;
  ResourceId?: string;
  ResourceType?: string;
}
export interface Explanation {
  Acl?: AnalysisComponent;
  AclRule?: AnalysisAclRule;
  Address?: string;
  Addresses?: string[];
  AttachedTo?: AnalysisComponent;
  AvailabilityZones?: string[];
  Cidrs?: string[];
  Component?: AnalysisComponent;
  CustomerGateway?: AnalysisComponent;
  Destination?: AnalysisComponent;
  DestinationVpc?: AnalysisComponent;
  Direction?: string;
  ExplanationCode?: string;
  IngressRouteTable?: AnalysisComponent;
  InternetGateway?: AnalysisComponent;
  LoadBalancerArn?: string;
  ClassicLoadBalancerListener?: AnalysisLoadBalancerListener;
  LoadBalancerListenerPort?: number;
  LoadBalancerTarget?: AnalysisLoadBalancerTarget;
  LoadBalancerTargetGroup?: AnalysisComponent;
  LoadBalancerTargetGroups?: AnalysisComponent[];
  LoadBalancerTargetPort?: number;
  ElasticLoadBalancerListener?: AnalysisComponent;
  MissingComponent?: string;
  NatGateway?: AnalysisComponent;
  NetworkInterface?: AnalysisComponent;
  PacketField?: string;
  VpcPeeringConnection?: AnalysisComponent;
  Port?: number;
  PortRanges?: PortRange[];
  PrefixList?: AnalysisComponent;
  Protocols?: string[];
  RouteTableRoute?: AnalysisRouteTableRoute;
  RouteTable?: AnalysisComponent;
  SecurityGroup?: AnalysisComponent;
  SecurityGroupRule?: AnalysisSecurityGroupRule;
  SecurityGroups?: AnalysisComponent[];
  SourceVpc?: AnalysisComponent;
  State?: string;
  Subnet?: AnalysisComponent;
  SubnetRouteTable?: AnalysisComponent;
  Vpc?: AnalysisComponent;
  VpcEndpoint?: AnalysisComponent;
  VpnConnection?: AnalysisComponent;
  VpnGateway?: AnalysisComponent;
  TransitGateway?: AnalysisComponent;
  TransitGatewayRouteTable?: AnalysisComponent;
  TransitGatewayRouteTableRoute?: TransitGatewayRouteTableRoute;
  TransitGatewayAttachment?: AnalysisComponent;
  ComponentAccount?: string;
  ComponentRegion?: string;
  FirewallStatelessRule?: FirewallStatelessRule;
  FirewallStatefulRule?: FirewallStatefulRule;
}
export interface AnalysisPacketHeader {
  DestinationAddresses?: string[];
  DestinationPortRanges?: PortRange[];
  Protocol?: string;
  SourceAddresses?: string[];
  SourcePortRanges?: PortRange[];
}
export interface PathComponent {
  SequenceNumber?: number;
  AclRule?: AnalysisAclRule;
  AttachedTo?: AnalysisComponent;
  Component?: AnalysisComponent;
  DestinationVpc?: AnalysisComponent;
  OutboundHeader?: AnalysisPacketHeader;
  InboundHeader?: AnalysisPacketHeader;
  RouteTableRoute?: AnalysisRouteTableRoute;
  SecurityGroupRule?: AnalysisSecurityGroupRule;
  SourceVpc?: AnalysisComponent;
  Subnet?: AnalysisComponent;
  Vpc?: AnalysisComponent;
  AdditionalDetails?: AdditionalDetail[];
  TransitGateway?: AnalysisComponent;
  TransitGatewayRouteTableRoute?: TransitGatewayRouteTableRoute;
  Explanations?: Explanation[];
  ElasticLoadBalancerListener?: AnalysisComponent;
  FirewallStatelessRule?: FirewallStatelessRule;
  FirewallStatefulRule?: FirewallStatefulRule;
  ServiceName?: string;
}
export interface AccessScopeAnalysisFinding {
  NetworkInsightsAccessScopeAnalysisId?: string;
  NetworkInsightsAccessScopeId?: string;
  FindingId?: string;
  FindingComponents?: PathComponent[];
}
export declare const Protocol: {
  readonly tcp: "tcp";
  readonly udp: "udp";
};
export type Protocol = (typeof Protocol)[keyof typeof Protocol];
export interface PacketHeaderStatement {
  SourceAddresses?: string[];
  DestinationAddresses?: string[];
  SourcePorts?: string[];
  DestinationPorts?: string[];
  SourcePrefixLists?: string[];
  DestinationPrefixLists?: string[];
  Protocols?: Protocol[];
}
export interface ResourceStatement {
  Resources?: string[];
  ResourceTypes?: string[];
}
export interface PathStatement {
  PacketHeaderStatement?: PacketHeaderStatement;
  ResourceStatement?: ResourceStatement;
}
export interface ThroughResourcesStatement {
  ResourceStatement?: ResourceStatement;
}
export interface AccessScopePath {
  Source?: PathStatement;
  Destination?: PathStatement;
  ThroughResources?: ThroughResourcesStatement[];
}
export interface PacketHeaderStatementRequest {
  SourceAddresses?: string[];
  DestinationAddresses?: string[];
  SourcePorts?: string[];
  DestinationPorts?: string[];
  SourcePrefixLists?: string[];
  DestinationPrefixLists?: string[];
  Protocols?: Protocol[];
}
export interface ResourceStatementRequest {
  Resources?: string[];
  ResourceTypes?: string[];
}
export interface PathStatementRequest {
  PacketHeaderStatement?: PacketHeaderStatementRequest;
  ResourceStatement?: ResourceStatementRequest;
}
export interface ThroughResourcesStatementRequest {
  ResourceStatement?: ResourceStatementRequest;
}
export interface AccessScopePathRequest {
  Source?: PathStatementRequest;
  Destination?: PathStatementRequest;
  ThroughResources?: ThroughResourcesStatementRequest[];
}
export interface AccountAttributeValue {
  AttributeValue?: string;
}
export interface AccountAttribute {
  AttributeName?: string;
  AttributeValues?: AccountAttributeValue[];
}
export declare const AccountAttributeName: {
  readonly default_vpc: "default-vpc";
  readonly supported_platforms: "supported-platforms";
};
export type AccountAttributeName =
  (typeof AccountAttributeName)[keyof typeof AccountAttributeName];
export declare const InstanceHealthStatus: {
  readonly HEALTHY_STATUS: "healthy";
  readonly UNHEALTHY_STATUS: "unhealthy";
};
export type InstanceHealthStatus =
  (typeof InstanceHealthStatus)[keyof typeof InstanceHealthStatus];
export interface ActiveInstance {
  InstanceId?: string;
  InstanceType?: string;
  SpotInstanceRequestId?: string;
  InstanceHealth?: InstanceHealthStatus;
}
export declare const ActivityStatus: {
  readonly ERROR: "error";
  readonly FULFILLED: "fulfilled";
  readonly PENDING_FULFILLMENT: "pending_fulfillment";
  readonly PENDING_TERMINATION: "pending_termination";
};
export type ActivityStatus =
  (typeof ActivityStatus)[keyof typeof ActivityStatus];
export declare const PrincipalType: {
  readonly Account: "Account";
  readonly All: "All";
  readonly OrganizationUnit: "OrganizationUnit";
  readonly Role: "Role";
  readonly Service: "Service";
  readonly User: "User";
};
export type PrincipalType = (typeof PrincipalType)[keyof typeof PrincipalType];
export interface AddedPrincipal {
  PrincipalType?: PrincipalType;
  Principal?: string;
  ServicePermissionId?: string;
  ServiceId?: string;
}
export interface AddIpamOperatingRegion {
  RegionName?: string;
}
export interface AddPrefixListEntry {
  Cidr: string | undefined;
  Description?: string;
}
export declare const DomainType: {
  readonly standard: "standard";
  readonly vpc: "vpc";
};
export type DomainType = (typeof DomainType)[keyof typeof DomainType];
export interface Address {
  AllocationId?: string;
  AssociationId?: string;
  Domain?: DomainType;
  NetworkInterfaceId?: string;
  NetworkInterfaceOwnerId?: string;
  PrivateIpAddress?: string;
  Tags?: Tag[];
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  CustomerOwnedIp?: string;
  CustomerOwnedIpv4Pool?: string;
  CarrierIp?: string;
  InstanceId?: string;
  PublicIp?: string;
}
export interface PtrUpdateStatus {
  Value?: string;
  Status?: string;
  Reason?: string;
}
export interface AddressAttribute {
  PublicIp?: string;
  AllocationId?: string;
  PtrRecord?: string;
  PtrRecordUpdate?: PtrUpdateStatus;
}
export declare const AddressAttributeName: {
  readonly domain_name: "domain-name";
};
export type AddressAttributeName =
  (typeof AddressAttributeName)[keyof typeof AddressAttributeName];
export declare const AddressFamily: {
  readonly ipv4: "ipv4";
  readonly ipv6: "ipv6";
};
export type AddressFamily = (typeof AddressFamily)[keyof typeof AddressFamily];
export interface AdvertiseByoipCidrRequest {
  Cidr: string | undefined;
  Asn?: string;
  DryRun?: boolean;
  NetworkBorderGroup?: string;
}
export declare const AsnAssociationState: {
  readonly associated: "associated";
  readonly disassociated: "disassociated";
  readonly failed_association: "failed-association";
  readonly failed_disassociation: "failed-disassociation";
  readonly pending_association: "pending-association";
  readonly pending_disassociation: "pending-disassociation";
};
export type AsnAssociationState =
  (typeof AsnAssociationState)[keyof typeof AsnAssociationState];
export interface AsnAssociation {
  Asn?: string;
  Cidr?: string;
  StatusMessage?: string;
  State?: AsnAssociationState;
}
export declare const ByoipCidrState: {
  readonly advertised: "advertised";
  readonly deprovisioned: "deprovisioned";
  readonly failed_deprovision: "failed-deprovision";
  readonly failed_provision: "failed-provision";
  readonly pending_deprovision: "pending-deprovision";
  readonly pending_provision: "pending-provision";
  readonly provisioned: "provisioned";
  readonly provisioned_not_publicly_advertisable: "provisioned-not-publicly-advertisable";
};
export type ByoipCidrState =
  (typeof ByoipCidrState)[keyof typeof ByoipCidrState];
export interface ByoipCidr {
  Cidr?: string;
  Description?: string;
  AsnAssociations?: AsnAssociation[];
  StatusMessage?: string;
  State?: ByoipCidrState;
  NetworkBorderGroup?: string;
}
export interface AdvertiseByoipCidrResult {
  ByoipCidr?: ByoipCidr;
}
export declare const Affinity: {
  readonly default: "default";
  readonly host: "host";
};
export type Affinity = (typeof Affinity)[keyof typeof Affinity];
export interface AllocateAddressRequest {
  Domain?: DomainType;
  Address?: string;
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  CustomerOwnedIpv4Pool?: string;
  TagSpecifications?: TagSpecification[];
  IpamPoolId?: string;
  DryRun?: boolean;
}
export interface AllocateAddressResult {
  AllocationId?: string;
  PublicIpv4Pool?: string;
  NetworkBorderGroup?: string;
  Domain?: DomainType;
  CustomerOwnedIp?: string;
  CustomerOwnedIpv4Pool?: string;
  CarrierIp?: string;
  PublicIp?: string;
}
export declare const AutoPlacement: {
  readonly off: "off";
  readonly on: "on";
};
export type AutoPlacement = (typeof AutoPlacement)[keyof typeof AutoPlacement];
export declare const HostMaintenance: {
  readonly off: "off";
  readonly on: "on";
};
export type HostMaintenance =
  (typeof HostMaintenance)[keyof typeof HostMaintenance];
export declare const HostRecovery: {
  readonly off: "off";
  readonly on: "on";
};
export type HostRecovery = (typeof HostRecovery)[keyof typeof HostRecovery];
export interface AllocateHostsRequest {
  InstanceFamily?: string;
  TagSpecifications?: TagSpecification[];
  HostRecovery?: HostRecovery;
  OutpostArn?: string;
  HostMaintenance?: HostMaintenance;
  AssetIds?: string[];
  AutoPlacement?: AutoPlacement;
  ClientToken?: string;
  InstanceType?: string;
  Quantity?: number;
  AvailabilityZone: string | undefined;
}
export interface AllocateHostsResult {
  HostIds?: string[];
}
export interface AllocateIpamPoolCidrRequest {
  DryRun?: boolean;
  IpamPoolId: string | undefined;
  Cidr?: string;
  NetmaskLength?: number;
  ClientToken?: string;
  Description?: string;
  PreviewNextCidr?: boolean;
  AllowedCidrs?: string[];
  DisallowedCidrs?: string[];
}
export declare const IpamPoolAllocationResourceType: {
  readonly custom: "custom";
  readonly ec2_public_ipv4_pool: "ec2-public-ipv4-pool";
  readonly eip: "eip";
  readonly ipam_pool: "ipam-pool";
  readonly subnet: "subnet";
  readonly vpc: "vpc";
};
export type IpamPoolAllocationResourceType =
  (typeof IpamPoolAllocationResourceType)[keyof typeof IpamPoolAllocationResourceType];
export interface IpamPoolAllocation {
  Cidr?: string;
  IpamPoolAllocationId?: string;
  Description?: string;
  ResourceId?: string;
  ResourceType?: IpamPoolAllocationResourceType;
  ResourceRegion?: string;
  ResourceOwner?: string;
}
export interface AllocateIpamPoolCidrResult {
  IpamPoolAllocation?: IpamPoolAllocation;
}
export declare const AllocationState: {
  readonly available: "available";
  readonly pending: "pending";
  readonly permanent_failure: "permanent-failure";
  readonly released: "released";
  readonly released_permanent_failure: "released-permanent-failure";
  readonly under_assessment: "under-assessment";
};
export type AllocationState =
  (typeof AllocationState)[keyof typeof AllocationState];
export declare const AllocationStrategy: {
  readonly CAPACITY_OPTIMIZED: "capacityOptimized";
  readonly CAPACITY_OPTIMIZED_PRIORITIZED: "capacityOptimizedPrioritized";
  readonly DIVERSIFIED: "diversified";
  readonly LOWEST_PRICE: "lowestPrice";
  readonly PRICE_CAPACITY_OPTIMIZED: "priceCapacityOptimized";
};
export type AllocationStrategy =
  (typeof AllocationStrategy)[keyof typeof AllocationStrategy];
export declare const AllocationType: {
  readonly used: "used";
};
export type AllocationType =
  (typeof AllocationType)[keyof typeof AllocationType];
export interface AllowedPrincipal {
  PrincipalType?: PrincipalType;
  Principal?: string;
  ServicePermissionId?: string;
  Tags?: Tag[];
  ServiceId?: string;
}
export declare const AllowsMultipleInstanceTypes: {
  readonly off: "off";
  readonly on: "on";
};
export type AllowsMultipleInstanceTypes =
  (typeof AllowsMultipleInstanceTypes)[keyof typeof AllowsMultipleInstanceTypes];
export interface AlternatePathHint {
  ComponentId?: string;
  ComponentArn?: string;
}
export interface ApplySecurityGroupsToClientVpnTargetNetworkRequest {
  ClientVpnEndpointId: string | undefined;
  VpcId: string | undefined;
  SecurityGroupIds: string[] | undefined;
  DryRun?: boolean;
}
export interface ApplySecurityGroupsToClientVpnTargetNetworkResult {
  SecurityGroupIds?: string[];
}
export interface AssignIpv6AddressesRequest {
  Ipv6PrefixCount?: number;
  Ipv6Prefixes?: string[];
  NetworkInterfaceId: string | undefined;
  Ipv6Addresses?: string[];
  Ipv6AddressCount?: number;
}
export interface AssignIpv6AddressesResult {
  AssignedIpv6Addresses?: string[];
  AssignedIpv6Prefixes?: string[];
  NetworkInterfaceId?: string;
}
export interface AssignPrivateIpAddressesRequest {
  Ipv4Prefixes?: string[];
  Ipv4PrefixCount?: number;
  NetworkInterfaceId: string | undefined;
  PrivateIpAddresses?: string[];
  SecondaryPrivateIpAddressCount?: number;
  AllowReassignment?: boolean;
}
export interface Ipv4PrefixSpecification {
  Ipv4Prefix?: string;
}
export interface AssignedPrivateIpAddress {
  PrivateIpAddress?: string;
}
export interface AssignPrivateIpAddressesResult {
  NetworkInterfaceId?: string;
  AssignedPrivateIpAddresses?: AssignedPrivateIpAddress[];
  AssignedIpv4Prefixes?: Ipv4PrefixSpecification[];
}
export interface AssignPrivateNatGatewayAddressRequest {
  NatGatewayId: string | undefined;
  PrivateIpAddresses?: string[];
  PrivateIpAddressCount?: number;
  DryRun?: boolean;
}
export declare const NatGatewayAddressStatus: {
  readonly ASSIGNING: "assigning";
  readonly ASSOCIATING: "associating";
  readonly DISASSOCIATING: "disassociating";
  readonly FAILED: "failed";
  readonly SUCCEEDED: "succeeded";
  readonly UNASSIGNING: "unassigning";
};
export type NatGatewayAddressStatus =
  (typeof NatGatewayAddressStatus)[keyof typeof NatGatewayAddressStatus];
export interface NatGatewayAddress {
  AllocationId?: string;
  NetworkInterfaceId?: string;
  PrivateIp?: string;
  PublicIp?: string;
  AssociationId?: string;
  IsPrimary?: boolean;
  FailureMessage?: string;
  Status?: NatGatewayAddressStatus;
}
export interface AssignPrivateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export interface AssociateAddressRequest {
  AllocationId?: string;
  InstanceId?: string;
  PublicIp?: string;
  DryRun?: boolean;
  NetworkInterfaceId?: string;
  PrivateIpAddress?: string;
  AllowReassociation?: boolean;
}
export interface AssociateAddressResult {
  AssociationId?: string;
}
export interface AssociateCapacityReservationBillingOwnerRequest {
  DryRun?: boolean;
  CapacityReservationId: string | undefined;
  UnusedReservationBillingOwnerId: string | undefined;
}
export interface AssociateCapacityReservationBillingOwnerResult {
  Return?: boolean;
}
export interface AssociateClientVpnTargetNetworkRequest {
  ClientVpnEndpointId: string | undefined;
  SubnetId: string | undefined;
  ClientToken?: string;
  DryRun?: boolean;
}
export declare const AssociationStatusCode: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly association_failed: "association-failed";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
};
export type AssociationStatusCode =
  (typeof AssociationStatusCode)[keyof typeof AssociationStatusCode];
export interface AssociationStatus {
  Code?: AssociationStatusCode;
  Message?: string;
}
export interface AssociateClientVpnTargetNetworkResult {
  AssociationId?: string;
  Status?: AssociationStatus;
}
export interface AssociateDhcpOptionsRequest {
  DhcpOptionsId: string | undefined;
  VpcId: string | undefined;
  DryRun?: boolean;
}
export interface AssociateEnclaveCertificateIamRoleRequest {
  CertificateArn: string | undefined;
  RoleArn: string | undefined;
  DryRun?: boolean;
}
export interface AssociateEnclaveCertificateIamRoleResult {
  CertificateS3BucketName?: string;
  CertificateS3ObjectKey?: string;
  EncryptionKmsKeyId?: string;
}
export interface IamInstanceProfileSpecification {
  Arn?: string;
  Name?: string;
}
export interface AssociateIamInstanceProfileRequest {
  IamInstanceProfile: IamInstanceProfileSpecification | undefined;
  InstanceId: string | undefined;
}
export interface IamInstanceProfile {
  Arn?: string;
  Id?: string;
}
export declare const IamInstanceProfileAssociationState: {
  readonly ASSOCIATED: "associated";
  readonly ASSOCIATING: "associating";
  readonly DISASSOCIATED: "disassociated";
  readonly DISASSOCIATING: "disassociating";
};
export type IamInstanceProfileAssociationState =
  (typeof IamInstanceProfileAssociationState)[keyof typeof IamInstanceProfileAssociationState];
export interface IamInstanceProfileAssociation {
  AssociationId?: string;
  InstanceId?: string;
  IamInstanceProfile?: IamInstanceProfile;
  State?: IamInstanceProfileAssociationState;
  Timestamp?: Date;
}
export interface AssociateIamInstanceProfileResult {
  IamInstanceProfileAssociation?: IamInstanceProfileAssociation;
}
export interface InstanceEventWindowAssociationRequest {
  InstanceIds?: string[];
  InstanceTags?: Tag[];
  DedicatedHostIds?: string[];
}
export interface AssociateInstanceEventWindowRequest {
  DryRun?: boolean;
  InstanceEventWindowId: string | undefined;
  AssociationTarget: InstanceEventWindowAssociationRequest | undefined;
}
export interface InstanceEventWindowAssociationTarget {
  InstanceIds?: string[];
  Tags?: Tag[];
  DedicatedHostIds?: string[];
}
export declare const InstanceEventWindowState: {
  readonly active: "active";
  readonly creating: "creating";
  readonly deleted: "deleted";
  readonly deleting: "deleting";
};
export type InstanceEventWindowState =
  (typeof InstanceEventWindowState)[keyof typeof InstanceEventWindowState];
export declare const WeekDay: {
  readonly friday: "friday";
  readonly monday: "monday";
  readonly saturday: "saturday";
  readonly sunday: "sunday";
  readonly thursday: "thursday";
  readonly tuesday: "tuesday";
  readonly wednesday: "wednesday";
};
export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay];
export interface InstanceEventWindowTimeRange {
  StartWeekDay?: WeekDay;
  StartHour?: number;
  EndWeekDay?: WeekDay;
  EndHour?: number;
}
export interface InstanceEventWindow {
  InstanceEventWindowId?: string;
  TimeRanges?: InstanceEventWindowTimeRange[];
  Name?: string;
  CronExpression?: string;
  AssociationTarget?: InstanceEventWindowAssociationTarget;
  State?: InstanceEventWindowState;
  Tags?: Tag[];
}
export interface AssociateInstanceEventWindowResult {
  InstanceEventWindow?: InstanceEventWindow;
}
export interface AssociateIpamByoasnRequest {
  DryRun?: boolean;
  Asn: string | undefined;
  Cidr: string | undefined;
}
export interface AssociateIpamByoasnResult {
  AsnAssociation?: AsnAssociation;
}
export interface AssociateIpamResourceDiscoveryRequest {
  DryRun?: boolean;
  IpamId: string | undefined;
  IpamResourceDiscoveryId: string | undefined;
  TagSpecifications?: TagSpecification[];
  ClientToken?: string;
}
export declare const IpamAssociatedResourceDiscoveryStatus: {
  readonly ACTIVE: "active";
  readonly NOT_FOUND: "not-found";
};
export type IpamAssociatedResourceDiscoveryStatus =
  (typeof IpamAssociatedResourceDiscoveryStatus)[keyof typeof IpamAssociatedResourceDiscoveryStatus];
export declare const IpamResourceDiscoveryAssociationState: {
  readonly ASSOCIATE_COMPLETE: "associate-complete";
  readonly ASSOCIATE_FAILED: "associate-failed";
  readonly ASSOCIATE_IN_PROGRESS: "associate-in-progress";
  readonly DISASSOCIATE_COMPLETE: "disassociate-complete";
  readonly DISASSOCIATE_FAILED: "disassociate-failed";
  readonly DISASSOCIATE_IN_PROGRESS: "disassociate-in-progress";
  readonly ISOLATE_COMPLETE: "isolate-complete";
  readonly ISOLATE_IN_PROGRESS: "isolate-in-progress";
  readonly RESTORE_IN_PROGRESS: "restore-in-progress";
};
export type IpamResourceDiscoveryAssociationState =
  (typeof IpamResourceDiscoveryAssociationState)[keyof typeof IpamResourceDiscoveryAssociationState];
export interface IpamResourceDiscoveryAssociation {
  OwnerId?: string;
  IpamResourceDiscoveryAssociationId?: string;
  IpamResourceDiscoveryAssociationArn?: string;
  IpamResourceDiscoveryId?: string;
  IpamId?: string;
  IpamArn?: string;
  IpamRegion?: string;
  IsDefault?: boolean;
  ResourceDiscoveryStatus?: IpamAssociatedResourceDiscoveryStatus;
  State?: IpamResourceDiscoveryAssociationState;
  Tags?: Tag[];
}
export interface AssociateIpamResourceDiscoveryResult {
  IpamResourceDiscoveryAssociation?: IpamResourceDiscoveryAssociation;
}
export interface AssociateNatGatewayAddressRequest {
  NatGatewayId: string | undefined;
  AllocationIds: string[] | undefined;
  PrivateIpAddresses?: string[];
  DryRun?: boolean;
}
export interface AssociateNatGatewayAddressResult {
  NatGatewayId?: string;
  NatGatewayAddresses?: NatGatewayAddress[];
}
export interface AssociateRouteTableRequest {
  GatewayId?: string;
  DryRun?: boolean;
  SubnetId?: string;
  RouteTableId: string | undefined;
}
export declare const RouteTableAssociationStateCode: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
  readonly failed: "failed";
};
export type RouteTableAssociationStateCode =
  (typeof RouteTableAssociationStateCode)[keyof typeof RouteTableAssociationStateCode];
export interface RouteTableAssociationState {
  State?: RouteTableAssociationStateCode;
  StatusMessage?: string;
}
export interface AssociateRouteTableResult {
  AssociationId?: string;
  AssociationState?: RouteTableAssociationState;
}
export interface AssociateSubnetCidrBlockRequest {
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  SubnetId: string | undefined;
  Ipv6CidrBlock?: string;
}
export declare const IpSource: {
  readonly amazon: "amazon";
  readonly byoip: "byoip";
  readonly none: "none";
};
export type IpSource = (typeof IpSource)[keyof typeof IpSource];
export declare const Ipv6AddressAttribute: {
  readonly private: "private";
  readonly public: "public";
};
export type Ipv6AddressAttribute =
  (typeof Ipv6AddressAttribute)[keyof typeof Ipv6AddressAttribute];
export declare const SubnetCidrBlockStateCode: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
  readonly failed: "failed";
  readonly failing: "failing";
};
export type SubnetCidrBlockStateCode =
  (typeof SubnetCidrBlockStateCode)[keyof typeof SubnetCidrBlockStateCode];
export interface SubnetCidrBlockState {
  State?: SubnetCidrBlockStateCode;
  StatusMessage?: string;
}
export interface SubnetIpv6CidrBlockAssociation {
  AssociationId?: string;
  Ipv6CidrBlock?: string;
  Ipv6CidrBlockState?: SubnetCidrBlockState;
  Ipv6AddressAttribute?: Ipv6AddressAttribute;
  IpSource?: IpSource;
}
export interface AssociateSubnetCidrBlockResult {
  Ipv6CidrBlockAssociation?: SubnetIpv6CidrBlockAssociation;
  SubnetId?: string;
}
export interface AssociateTransitGatewayMulticastDomainRequest {
  TransitGatewayMulticastDomainId: string | undefined;
  TransitGatewayAttachmentId: string | undefined;
  SubnetIds: string[] | undefined;
  DryRun?: boolean;
}
export interface AssociateTransitGatewayMulticastDomainResult {
  Associations?: TransitGatewayMulticastDomainAssociations;
}
export interface AssociateTransitGatewayPolicyTableRequest {
  TransitGatewayPolicyTableId: string | undefined;
  TransitGatewayAttachmentId: string | undefined;
  DryRun?: boolean;
}
export declare const TransitGatewayAssociationState: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
};
export type TransitGatewayAssociationState =
  (typeof TransitGatewayAssociationState)[keyof typeof TransitGatewayAssociationState];
export interface TransitGatewayPolicyTableAssociation {
  TransitGatewayPolicyTableId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayAssociationState;
}
export interface AssociateTransitGatewayPolicyTableResult {
  Association?: TransitGatewayPolicyTableAssociation;
}
export interface AssociateTransitGatewayRouteTableRequest {
  TransitGatewayRouteTableId: string | undefined;
  TransitGatewayAttachmentId: string | undefined;
  DryRun?: boolean;
}
export interface TransitGatewayAssociation {
  TransitGatewayRouteTableId?: string;
  TransitGatewayAttachmentId?: string;
  ResourceId?: string;
  ResourceType?: TransitGatewayAttachmentResourceType;
  State?: TransitGatewayAssociationState;
}
export interface AssociateTransitGatewayRouteTableResult {
  Association?: TransitGatewayAssociation;
}
export interface AssociateTrunkInterfaceRequest {
  BranchInterfaceId: string | undefined;
  TrunkInterfaceId: string | undefined;
  VlanId?: number;
  GreKey?: number;
  ClientToken?: string;
  DryRun?: boolean;
}
export declare const InterfaceProtocolType: {
  readonly GRE: "GRE";
  readonly VLAN: "VLAN";
};
export type InterfaceProtocolType =
  (typeof InterfaceProtocolType)[keyof typeof InterfaceProtocolType];
export interface TrunkInterfaceAssociation {
  AssociationId?: string;
  BranchInterfaceId?: string;
  TrunkInterfaceId?: string;
  InterfaceProtocol?: InterfaceProtocolType;
  VlanId?: number;
  GreKey?: number;
  Tags?: Tag[];
}
export interface AssociateTrunkInterfaceResult {
  InterfaceAssociation?: TrunkInterfaceAssociation;
  ClientToken?: string;
}
export interface AssociateVpcCidrBlockRequest {
  CidrBlock?: string;
  Ipv6CidrBlockNetworkBorderGroup?: string;
  Ipv6Pool?: string;
  Ipv6CidrBlock?: string;
  Ipv4IpamPoolId?: string;
  Ipv4NetmaskLength?: number;
  Ipv6IpamPoolId?: string;
  Ipv6NetmaskLength?: number;
  VpcId: string | undefined;
  AmazonProvidedIpv6CidrBlock?: boolean;
}
export declare const VpcCidrBlockStateCode: {
  readonly associated: "associated";
  readonly associating: "associating";
  readonly disassociated: "disassociated";
  readonly disassociating: "disassociating";
  readonly failed: "failed";
  readonly failing: "failing";
};
export type VpcCidrBlockStateCode =
  (typeof VpcCidrBlockStateCode)[keyof typeof VpcCidrBlockStateCode];
export interface VpcCidrBlockState {
  State?: VpcCidrBlockStateCode;
  StatusMessage?: string;
}
export interface VpcCidrBlockAssociation {
  AssociationId?: string;
  CidrBlock?: string;
  CidrBlockState?: VpcCidrBlockState;
}
export interface VpcIpv6CidrBlockAssociation {
  AssociationId?: string;
  Ipv6CidrBlock?: string;
  Ipv6CidrBlockState?: VpcCidrBlockState;
  NetworkBorderGroup?: string;
  Ipv6Pool?: string;
  Ipv6AddressAttribute?: Ipv6AddressAttribute;
  IpSource?: IpSource;
}
export interface AssociateVpcCidrBlockResult {
  Ipv6CidrBlockAssociation?: VpcIpv6CidrBlockAssociation;
  CidrBlockAssociation?: VpcCidrBlockAssociation;
  VpcId?: string;
}
export interface AttachClassicLinkVpcRequest {
  DryRun?: boolean;
  InstanceId: string | undefined;
  VpcId: string | undefined;
  Groups: string[] | undefined;
}
export interface AttachClassicLinkVpcResult {
  Return?: boolean;
}
export interface AttachInternetGatewayRequest {
  DryRun?: boolean;
  InternetGatewayId: string | undefined;
  VpcId: string | undefined;
}
export interface EnaSrdUdpSpecification {
  EnaSrdUdpEnabled?: boolean;
}
export interface EnaSrdSpecification {
  EnaSrdEnabled?: boolean;
  EnaSrdUdpSpecification?: EnaSrdUdpSpecification;
}
export interface AttachNetworkInterfaceRequest {
  NetworkCardIndex?: number;
  EnaSrdSpecification?: EnaSrdSpecification;
  DryRun?: boolean;
  NetworkInterfaceId: string | undefined;
  InstanceId: string | undefined;
  DeviceIndex: number | undefined;
}
export interface AttachNetworkInterfaceResult {
  AttachmentId?: string;
  NetworkCardIndex?: number;
}
export interface AttachVerifiedAccessTrustProviderRequest {
  VerifiedAccessInstanceId: string | undefined;
  VerifiedAccessTrustProviderId: string | undefined;
  ClientToken?: string;
  DryRun?: boolean;
}
export declare const DeviceTrustProviderType: {
  readonly crowdstrike: "crowdstrike";
  readonly jamf: "jamf";
  readonly jumpcloud: "jumpcloud";
};
export type DeviceTrustProviderType =
  (typeof DeviceTrustProviderType)[keyof typeof DeviceTrustProviderType];
export declare const TrustProviderType: {
  readonly device: "device";
  readonly user: "user";
};
export type TrustProviderType =
  (typeof TrustProviderType)[keyof typeof TrustProviderType];
export declare const UserTrustProviderType: {
  readonly iam_identity_center: "iam-identity-center";
  readonly oidc: "oidc";
};
export type UserTrustProviderType =
  (typeof UserTrustProviderType)[keyof typeof UserTrustProviderType];
export interface VerifiedAccessTrustProviderCondensed {
  VerifiedAccessTrustProviderId?: string;
  Description?: string;
  TrustProviderType?: TrustProviderType;
  UserTrustProviderType?: UserTrustProviderType;
  DeviceTrustProviderType?: DeviceTrustProviderType;
}
export interface VerifiedAccessInstance {
  VerifiedAccessInstanceId?: string;
  Description?: string;
  VerifiedAccessTrustProviders?: VerifiedAccessTrustProviderCondensed[];
  CreationTime?: string;
  LastUpdatedTime?: string;
  Tags?: Tag[];
  FipsEnabled?: boolean;
}
export interface DeviceOptions {
  TenantId?: string;
  PublicSigningKeyUrl?: string;
}
export interface OidcOptions {
  Issuer?: string;
  AuthorizationEndpoint?: string;
  TokenEndpoint?: string;
  UserInfoEndpoint?: string;
  ClientId?: string;
  ClientSecret?: string;
  Scope?: string;
}
export interface VerifiedAccessSseSpecificationResponse {
  CustomerManagedKeyEnabled?: boolean;
  KmsKeyArn?: string;
}
export interface VerifiedAccessTrustProvider {
  VerifiedAccessTrustProviderId?: string;
  Description?: string;
  TrustProviderType?: TrustProviderType;
  UserTrustProviderType?: UserTrustProviderType;
  DeviceTrustProviderType?: DeviceTrustProviderType;
  OidcOptions?: OidcOptions;
  DeviceOptions?: DeviceOptions;
  PolicyReferenceName?: string;
  CreationTime?: string;
  LastUpdatedTime?: string;
  Tags?: Tag[];
  SseSpecification?: VerifiedAccessSseSpecificationResponse;
}
export interface AttachVerifiedAccessTrustProviderResult {
  VerifiedAccessTrustProvider?: VerifiedAccessTrustProvider;
  VerifiedAccessInstance?: VerifiedAccessInstance;
}
export interface AttachVolumeRequest {
  Device: string | undefined;
  InstanceId: string | undefined;
  VolumeId: string | undefined;
  DryRun?: boolean;
}
export declare const VolumeAttachmentState: {
  readonly attached: "attached";
  readonly attaching: "attaching";
  readonly busy: "busy";
  readonly detached: "detached";
  readonly detaching: "detaching";
};
export type VolumeAttachmentState =
  (typeof VolumeAttachmentState)[keyof typeof VolumeAttachmentState];
export interface VolumeAttachment {
  DeleteOnTermination?: boolean;
  AssociatedResource?: string;
  InstanceOwningService?: string;
  VolumeId?: string;
  InstanceId?: string;
  Device?: string;
  State?: VolumeAttachmentState;
  AttachTime?: Date;
}
export interface AttachVpnGatewayRequest {
  VpcId: string | undefined;
  VpnGatewayId: string | undefined;
  DryRun?: boolean;
}
export declare const AttachmentStatus: {
  readonly attached: "attached";
  readonly attaching: "attaching";
  readonly detached: "detached";
  readonly detaching: "detaching";
};
export type AttachmentStatus =
  (typeof AttachmentStatus)[keyof typeof AttachmentStatus];
export interface VpcAttachment {
  VpcId?: string;
  State?: AttachmentStatus;
}
export interface AttachVpnGatewayResult {
  VpcAttachment?: VpcAttachment;
}
export interface AuthorizeClientVpnIngressRequest {
  ClientVpnEndpointId: string | undefined;
  TargetNetworkCidr: string | undefined;
  AccessGroupId?: string;
  AuthorizeAllGroups?: boolean;
  Description?: string;
  ClientToken?: string;
  DryRun?: boolean;
}
export declare const ClientVpnAuthorizationRuleStatusCode: {
  readonly active: "active";
  readonly authorizing: "authorizing";
  readonly failed: "failed";
  readonly revoking: "revoking";
};
export type ClientVpnAuthorizationRuleStatusCode =
  (typeof ClientVpnAuthorizationRuleStatusCode)[keyof typeof ClientVpnAuthorizationRuleStatusCode];
export interface ClientVpnAuthorizationRuleStatus {
  Code?: ClientVpnAuthorizationRuleStatusCode;
  Message?: string;
}
export interface AuthorizeClientVpnIngressResult {
  Status?: ClientVpnAuthorizationRuleStatus;
}
export interface IpRange {
  Description?: string;
  CidrIp?: string;
}
export interface Ipv6Range {
  Description?: string;
  CidrIpv6?: string;
}
export interface PrefixListId {
  Description?: string;
  PrefixListId?: string;
}
export interface UserIdGroupPair {
  Description?: string;
  UserId?: string;
  GroupName?: string;
  GroupId?: string;
  VpcId?: string;
  VpcPeeringConnectionId?: string;
  PeeringStatus?: string;
}
export interface IpPermission {
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  UserIdGroupPairs?: UserIdGroupPair[];
  IpRanges?: IpRange[];
  Ipv6Ranges?: Ipv6Range[];
  PrefixListIds?: PrefixListId[];
}
export interface AuthorizeSecurityGroupEgressRequest {
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  GroupId: string | undefined;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIp?: string;
  IpPermissions?: IpPermission[];
}
export interface ReferencedSecurityGroup {
  GroupId?: string;
  PeeringStatus?: string;
  UserId?: string;
  VpcId?: string;
  VpcPeeringConnectionId?: string;
}
export interface SecurityGroupRule {
  SecurityGroupRuleId?: string;
  GroupId?: string;
  GroupOwnerId?: string;
  IsEgress?: boolean;
  IpProtocol?: string;
  FromPort?: number;
  ToPort?: number;
  CidrIpv4?: string;
  CidrIpv6?: string;
  PrefixListId?: string;
  ReferencedGroupInfo?: ReferencedSecurityGroup;
  Description?: string;
  Tags?: Tag[];
}
export interface AuthorizeSecurityGroupEgressResult {
  Return?: boolean;
  SecurityGroupRules?: SecurityGroupRule[];
}
export interface AuthorizeSecurityGroupIngressRequest {
  CidrIp?: string;
  FromPort?: number;
  GroupId?: string;
  GroupName?: string;
  IpPermissions?: IpPermission[];
  IpProtocol?: string;
  SourceSecurityGroupName?: string;
  SourceSecurityGroupOwnerId?: string;
  ToPort?: number;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export interface AuthorizeSecurityGroupIngressResult {
  Return?: boolean;
  SecurityGroupRules?: SecurityGroupRule[];
}
export interface S3Storage {
  AWSAccessKeyId?: string;
  Bucket?: string;
  Prefix?: string;
  UploadPolicy?: Uint8Array;
  UploadPolicySignature?: string;
}
export interface Storage {
  S3?: S3Storage;
}
export interface BundleInstanceRequest {
  InstanceId: string | undefined;
  Storage: Storage | undefined;
  DryRun?: boolean;
}
export interface BundleTaskError {
  Code?: string;
  Message?: string;
}
export declare const BundleTaskState: {
  readonly bundling: "bundling";
  readonly cancelling: "cancelling";
  readonly complete: "complete";
  readonly failed: "failed";
  readonly pending: "pending";
  readonly storing: "storing";
  readonly waiting_for_shutdown: "waiting-for-shutdown";
};
export type BundleTaskState =
  (typeof BundleTaskState)[keyof typeof BundleTaskState];
export interface BundleTask {
  InstanceId?: string;
  BundleId?: string;
  State?: BundleTaskState;
  StartTime?: Date;
  UpdateTime?: Date;
  Storage?: Storage;
  Progress?: string;
  BundleTaskError?: BundleTaskError;
}
export interface BundleInstanceResult {
  BundleTask?: BundleTask;
}
export interface CancelBundleTaskRequest {
  BundleId: string | undefined;
  DryRun?: boolean;
}
export interface CancelBundleTaskResult {
  BundleTask?: BundleTask;
}
export interface CancelCapacityReservationRequest {
  CapacityReservationId: string | undefined;
  DryRun?: boolean;
}
export interface CancelCapacityReservationResult {
  Return?: boolean;
}
export interface CancelCapacityReservationFleetsRequest {
  DryRun?: boolean;
  CapacityReservationFleetIds: string[] | undefined;
}
export interface CancelCapacityReservationFleetError {
  Code?: string;
  Message?: string;
}
export interface FailedCapacityReservationFleetCancellationResult {
  CapacityReservationFleetId?: string;
  CancelCapacityReservationFleetError?: CancelCapacityReservationFleetError;
}
export declare const CapacityReservationFleetState: {
  readonly ACTIVE: "active";
  readonly CANCELLED: "cancelled";
  readonly CANCELLING: "cancelling";
  readonly EXPIRED: "expired";
  readonly EXPIRING: "expiring";
  readonly FAILED: "failed";
  readonly MODIFYING: "modifying";
  readonly PARTIALLY_FULFILLED: "partially_fulfilled";
  readonly SUBMITTED: "submitted";
};
export type CapacityReservationFleetState =
  (typeof CapacityReservationFleetState)[keyof typeof CapacityReservationFleetState];
export interface CapacityReservationFleetCancellationState {
  CurrentFleetState?: CapacityReservationFleetState;
  PreviousFleetState?: CapacityReservationFleetState;
  CapacityReservationFleetId?: string;
}
export interface CancelCapacityReservationFleetsResult {
  SuccessfulFleetCancellations?: CapacityReservationFleetCancellationState[];
  FailedFleetCancellations?: FailedCapacityReservationFleetCancellationResult[];
}
export interface CancelConversionRequest {
  DryRun?: boolean;
  ConversionTaskId: string | undefined;
  ReasonMessage?: string;
}
export interface CancelExportTaskRequest {
  ExportTaskId: string | undefined;
}
export interface CancelImageLaunchPermissionRequest {
  ImageId: string | undefined;
  DryRun?: boolean;
}
export interface CancelImageLaunchPermissionResult {
  Return?: boolean;
}
export interface CancelImportTaskRequest {
  CancelReason?: string;
  DryRun?: boolean;
  ImportTaskId?: string;
}
export interface CancelImportTaskResult {
  ImportTaskId?: string;
  PreviousState?: string;
  State?: string;
}
export interface CancelReservedInstancesListingRequest {
  ReservedInstancesListingId: string | undefined;
}
export declare const ListingState: {
  readonly available: "available";
  readonly cancelled: "cancelled";
  readonly pending: "pending";
  readonly sold: "sold";
};
export type ListingState = (typeof ListingState)[keyof typeof ListingState];
export interface InstanceCount {
  InstanceCount?: number;
  State?: ListingState;
}
export declare const CurrencyCodeValues: {
  readonly USD: "USD";
};
export type CurrencyCodeValues =
  (typeof CurrencyCodeValues)[keyof typeof CurrencyCodeValues];
export interface PriceSchedule {
  Active?: boolean;
  CurrencyCode?: CurrencyCodeValues;
  Price?: number;
  Term?: number;
}
export declare const ListingStatus: {
  readonly active: "active";
  readonly cancelled: "cancelled";
  readonly closed: "closed";
  readonly pending: "pending";
};
export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus];
export interface ReservedInstancesListing {
  ClientToken?: string;
  CreateDate?: Date;
  InstanceCounts?: InstanceCount[];
  PriceSchedules?: PriceSchedule[];
  ReservedInstancesId?: string;
  ReservedInstancesListingId?: string;
  Status?: ListingStatus;
  StatusMessage?: string;
  Tags?: Tag[];
  UpdateDate?: Date;
}
export interface CancelReservedInstancesListingResult {
  ReservedInstancesListings?: ReservedInstancesListing[];
}
export interface CancelSpotFleetRequestsRequest {
  DryRun?: boolean;
  SpotFleetRequestIds: string[] | undefined;
  TerminateInstances: boolean | undefined;
}
export declare const BatchState: {
  readonly ACTIVE: "active";
  readonly CANCELLED: "cancelled";
  readonly CANCELLED_RUNNING: "cancelled_running";
  readonly CANCELLED_TERMINATING_INSTANCES: "cancelled_terminating";
  readonly FAILED: "failed";
  readonly MODIFYING: "modifying";
  readonly SUBMITTED: "submitted";
};
export type BatchState = (typeof BatchState)[keyof typeof BatchState];
export interface CancelSpotFleetRequestsSuccessItem {
  CurrentSpotFleetRequestState?: BatchState;
  PreviousSpotFleetRequestState?: BatchState;
  SpotFleetRequestId?: string;
}
export declare const CancelBatchErrorCode: {
  readonly FLEET_REQUEST_ID_DOES_NOT_EXIST: "fleetRequestIdDoesNotExist";
  readonly FLEET_REQUEST_ID_MALFORMED: "fleetRequestIdMalformed";
  readonly FLEET_REQUEST_NOT_IN_CANCELLABLE_STATE: "fleetRequestNotInCancellableState";
  readonly UNEXPECTED_ERROR: "unexpectedError";
};
export type CancelBatchErrorCode =
  (typeof CancelBatchErrorCode)[keyof typeof CancelBatchErrorCode];
export interface CancelSpotFleetRequestsError {
  Code?: CancelBatchErrorCode;
  Message?: string;
}
export interface CancelSpotFleetRequestsErrorItem {
  Error?: CancelSpotFleetRequestsError;
  SpotFleetRequestId?: string;
}
export interface CancelSpotFleetRequestsResponse {
  SuccessfulFleetRequests?: CancelSpotFleetRequestsSuccessItem[];
  UnsuccessfulFleetRequests?: CancelSpotFleetRequestsErrorItem[];
}
export interface CancelSpotInstanceRequestsRequest {
  DryRun?: boolean;
  SpotInstanceRequestIds: string[] | undefined;
}
export declare const CancelSpotInstanceRequestState: {
  readonly active: "active";
  readonly cancelled: "cancelled";
  readonly closed: "closed";
  readonly completed: "completed";
  readonly open: "open";
};
export type CancelSpotInstanceRequestState =
  (typeof CancelSpotInstanceRequestState)[keyof typeof CancelSpotInstanceRequestState];
export interface CancelledSpotInstanceRequest {
  SpotInstanceRequestId?: string;
  State?: CancelSpotInstanceRequestState;
}
export interface CancelSpotInstanceRequestsResult {
  CancelledSpotInstanceRequests?: CancelledSpotInstanceRequest[];
}
export interface ConfirmProductInstanceRequest {
  InstanceId: string | undefined;
  ProductCode: string | undefined;
  DryRun?: boolean;
}
export interface ConfirmProductInstanceResult {
  Return?: boolean;
  OwnerId?: string;
}
export interface CopyFpgaImageRequest {
  DryRun?: boolean;
  SourceFpgaImageId: string | undefined;
  Description?: string;
  Name?: string;
  SourceRegion: string | undefined;
  ClientToken?: string;
}
export interface CopyFpgaImageResult {
  FpgaImageId?: string;
}
export interface CopyImageRequest {
  ClientToken?: string;
  Description?: string;
  Encrypted?: boolean;
  KmsKeyId?: string;
  Name: string | undefined;
  SourceImageId: string | undefined;
  SourceRegion: string | undefined;
  DestinationOutpostArn?: string;
  CopyImageTags?: boolean;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export interface CopyImageResult {
  ImageId?: string;
}
export interface CopySnapshotRequest {
  Description?: string;
  DestinationOutpostArn?: string;
  DestinationRegion?: string;
  Encrypted?: boolean;
  KmsKeyId?: string;
  PresignedUrl?: string;
  SourceRegion: string | undefined;
  SourceSnapshotId: string | undefined;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
}
export interface CopySnapshotResult {
  Tags?: Tag[];
  SnapshotId?: string;
}
export declare const EndDateType: {
  readonly limited: "limited";
  readonly unlimited: "unlimited";
};
export type EndDateType = (typeof EndDateType)[keyof typeof EndDateType];
export declare const InstanceMatchCriteria: {
  readonly open: "open";
  readonly targeted: "targeted";
};
export type InstanceMatchCriteria =
  (typeof InstanceMatchCriteria)[keyof typeof InstanceMatchCriteria];
export declare const CapacityReservationInstancePlatform: {
  readonly LINUX_UNIX: "Linux/UNIX";
  readonly LINUX_WITH_SQL_SERVER_ENTERPRISE: "Linux with SQL Server Enterprise";
  readonly LINUX_WITH_SQL_SERVER_STANDARD: "Linux with SQL Server Standard";
  readonly LINUX_WITH_SQL_SERVER_WEB: "Linux with SQL Server Web";
  readonly RED_HAT_ENTERPRISE_LINUX: "Red Hat Enterprise Linux";
  readonly RHEL_WITH_HA: "RHEL with HA";
  readonly RHEL_WITH_HA_AND_SQL_SERVER_ENTERPRISE: "RHEL with HA and SQL Server Enterprise";
  readonly RHEL_WITH_HA_AND_SQL_SERVER_STANDARD: "RHEL with HA and SQL Server Standard";
  readonly RHEL_WITH_SQL_SERVER_ENTERPRISE: "RHEL with SQL Server Enterprise";
  readonly RHEL_WITH_SQL_SERVER_STANDARD: "RHEL with SQL Server Standard";
  readonly RHEL_WITH_SQL_SERVER_WEB: "RHEL with SQL Server Web";
  readonly SUSE_LINUX: "SUSE Linux";
  readonly UBUNTU_PRO_LINUX: "Ubuntu Pro";
  readonly WINDOWS: "Windows";
  readonly WINDOWS_WITH_SQL_SERVER: "Windows with SQL Server";
  readonly WINDOWS_WITH_SQL_SERVER_ENTERPRISE: "Windows with SQL Server Enterprise";
  readonly WINDOWS_WITH_SQL_SERVER_STANDARD: "Windows with SQL Server Standard";
  readonly WINDOWS_WITH_SQL_SERVER_WEB: "Windows with SQL Server Web";
};
export type CapacityReservationInstancePlatform =
  (typeof CapacityReservationInstancePlatform)[keyof typeof CapacityReservationInstancePlatform];
export declare const CapacityReservationTenancy: {
  readonly dedicated: "dedicated";
  readonly default: "default";
};
export type CapacityReservationTenancy =
  (typeof CapacityReservationTenancy)[keyof typeof CapacityReservationTenancy];
export interface CreateCapacityReservationRequest {
  ClientToken?: string;
  InstanceType: string | undefined;
  InstancePlatform: CapacityReservationInstancePlatform | undefined;
  AvailabilityZone?: string;
  AvailabilityZoneId?: string;
  Tenancy?: CapacityReservationTenancy;
  InstanceCount: number | undefined;
  EbsOptimized?: boolean;
  EphemeralStorage?: boolean;
  EndDate?: Date;
  EndDateType?: EndDateType;
  InstanceMatchCriteria?: InstanceMatchCriteria;
  TagSpecifications?: TagSpecification[];
  DryRun?: boolean;
  OutpostArn?: string;
  PlacementGroupArn?: string;
}
export interface CapacityAllocation {
  AllocationType?: AllocationType;
  Count?: number;
}
export declare const CapacityReservationType: {
  readonly CAPACITY_BLOCK: "capacity-block";
  readonly DEFAULT: "default";
};
export type CapacityReservationType =
  (typeof CapacityReservationType)[keyof typeof CapacityReservationType];
export declare const CapacityReservationState: {
  readonly active: "active";
  readonly cancelled: "cancelled";
  readonly expired: "expired";
  readonly failed: "failed";
  readonly payment_failed: "payment-failed";
  readonly payment_pending: "payment-pending";
  readonly pending: "pending";
  readonly scheduled: "scheduled";
};
export type CapacityReservationState =
  (typeof CapacityReservationState)[keyof typeof CapacityReservationState];
export interface CapacityReservation {
  CapacityReservationId?: string;
  OwnerId?: string;
  CapacityReservationArn?: string;
  AvailabilityZoneId?: string;
  InstanceType?: string;
  InstancePlatform?: CapacityReservationInstancePlatform;
  AvailabilityZone?: string;
  Tenancy?: CapacityReservationTenancy;
  TotalInstanceCount?: number;
  AvailableInstanceCount?: number;
  EbsOptimized?: boolean;
  EphemeralStorage?: boolean;
  State?: CapacityReservationState;
  StartDate?: Date;
  EndDate?: Date;
  EndDateType?: EndDateType;
  InstanceMatchCriteria?: InstanceMatchCriteria;
  CreateDate?: Date;
  Tags?: Tag[];
  OutpostArn?: string;
  CapacityReservationFleetId?: string;
  PlacementGroupArn?: string;
  CapacityAllocations?: CapacityAllocation[];
  ReservationType?: CapacityReservationType;
  UnusedReservationBillingOwnerId?: string;
}
export interface CreateCapacityReservationResult {
  CapacityReservation?: CapacityReservation;
}
export interface CreateCapacityReservationBySplittingRequest {
  DryRun?: boolean;
  ClientToken?: string;
  SourceCapacityReservationId: string | undefined;
  InstanceCount: number | undefined;
  TagSpecifications?: TagSpecification[];
}
export declare const OidcOptionsFilterSensitiveLog: (obj: OidcOptions) => any;
export declare const VerifiedAccessTrustProviderFilterSensitiveLog: (
  obj: VerifiedAccessTrustProvider
) => any;
export declare const AttachVerifiedAccessTrustProviderResultFilterSensitiveLog: (
  obj: AttachVerifiedAccessTrustProviderResult
) => any;
export declare const S3StorageFilterSensitiveLog: (obj: S3Storage) => any;
export declare const StorageFilterSensitiveLog: (obj: Storage) => any;
export declare const BundleInstanceRequestFilterSensitiveLog: (
  obj: BundleInstanceRequest
) => any;
export declare const BundleTaskFilterSensitiveLog: (obj: BundleTask) => any;
export declare const BundleInstanceResultFilterSensitiveLog: (
  obj: BundleInstanceResult
) => any;
export declare const CancelBundleTaskResultFilterSensitiveLog: (
  obj: CancelBundleTaskResult
) => any;
export declare const CopySnapshotRequestFilterSensitiveLog: (
  obj: CopySnapshotRequest
) => any;
